from gates import switch, switch_density, QuditLateSPhoton, QuditEarlySPhoton, X_full_matrix, \
    X_half_matrix, CNOT
from spin_rotation import LC_Z_spin, LC_rotations_photons, gen_box, gates_state_sec
import numpy as np

def stab_ancilla_meas(state_box, H_gate_photon_1, identity, S):
    cnotSA, cnotPA = CNOT()
    ancilla = np.array([1, 0, 0, 0], dtype=np.complex128)
    ancilla1 = np.array([0, 1, 0, 0], dtype=np.complex128)
    H_gate_photon_1 = np.kron(H_gate_photon_1, identity)
    cnotPA = np.kron(np.kron(np.kron(cnotPA, identity), identity), identity)
    cnotSA = np.kron(np.kron(np.kron(cnotSA, identity), identity), identity)

    H_S = np.array([[1 / np.sqrt(2), 1 / np.sqrt(2), 0, 0],
                         [1 / np.sqrt(2), -1 / np.sqrt(2), 0, 0],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]], dtype=np.complex128)
    H_S = np.kron(np.kron(np.kron(np.kron(H_S, identity), identity), identity), identity)


    if S == "1":
        state = np.kron(state_box, ancilla)
        state1 = np.kron(state_box, ancilla1)
        error_gate = np.array([[1, 0, 0, 0],
                               [0, 1, 0, 0],
                               [0, 0, -1, 0],
                               [0, 0, 0, 1]], dtype=np.complex128)
        error_gate = np.kron(np.kron(np.kron(np.kron(error_gate, identity), identity), identity), identity)
        state1 = np.matmul(H_S, state1)
        state = np.matmul(error_gate, state)
        state0 = state


        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)

        # Second CNOT
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)

        # Third CNOT and H
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        state = np.matmul(H_gate_photon_1, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        state = np.matmul(H_gate_photon_1, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        P0 = abs(np.matmul(np.conjugate(state0).transpose(), state)) ** 2
        P1 = abs(np.matmul(np.conjugate(state1).transpose(), state)) ** 2
        print("Probability of measuring the ancilla qubit in state |0> is {} while in state |1> is {}".format(P0, P1))

        return state, state0, state1

    if S == "2":
        state = np.kron(state_box, ancilla)
        state1 = np.kron(state_box, ancilla1)
        error_gate = np.array([[0, 1, 0, 0],
                               [1, 0, 0, 0],
                               [0, 0, 1, 0],
                               [0, 0, 0, 1]], dtype=np.complex128)
        error_gate = np.kron(np.kron(np.kron(np.kron(error_gate, identity), identity), identity), identity)
        state1 = np.matmul(error_gate, state1)
        state = np.matmul(error_gate, state)
        state0 = state
        # First CNOT
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotSA, state)

        # Second CNOT and H
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        state = np.matmul(H_gate_photon_1, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        state = np.matmul(H_gate_photon_1, state)

        # Third CNOT
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)

        v, state = switch(state, numb_photons + 2)

        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)

        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)

        v, state = switch(state, numb_photons + 1)

        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)

        #state = np.matmul(H_anc, state)
        P0 = abs(np.matmul(np.conjugate(state0).transpose(), state)) ** 2
        P1 = abs(np.matmul(np.conjugate(state1).transpose(), state)) ** 2
        print("Probability of measuring the ancilla qubit in state |0> is {} while in state |1> is {}".format(P0, P1))

        return state, state0, state1


    if S == "3":
        state = np.kron(state_box, ancilla)
        state1 = np.kron(state_box, ancilla1)
        error_gate = np.array([[0, -1j, 0, 0],
                               [1j, 0, 0, 0],
                               [0, 0, 1, 0],
                               [0, 0, 0, 1]], dtype=np.complex128)
        error_gate = np.kron(np.kron(np.kron(np.kron(error_gate, identity), identity), identity), identity)
        state1 = np.matmul(error_gate, state1)
        state = np.matmul(error_gate, state)
        state0 = state

        # First CNOT and H
        state = np.matmul(H_S, state)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotSA, state)
        state = np.matmul(H_S, state)

        # Second CNOT
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)

        # Third CNOT
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 1)
        state = np.matmul(cnotPA, state)
        v, state = switch(state, numb_photons + 2)
        v, state = switch(state, numb_photons + 1)
        v, state = switch(state, numb_photons + 2)

        P0 = abs(np.matmul(np.conjugate(state0).transpose(), state)) ** 2
        P1 = abs(np.matmul(np.conjugate(state1).transpose(), state)) ** 2
        print("Probability of measuring the ancilla qubit in state |0> is {} while in state |1> is {}".format(P0, P1))

        return state, state0, state1


if __name__ == "__main__":
    numb_photons = 3
    kappa = 0.00000000002
    beta_par = 0.992
    beta_ort = 0.072
    cross_ex = 0.1  # 1.7 * 10 ** (-2)

    # GET MATRICES
    ex, ex_perfect, early_gate, late_gate, state, C1, C2, pi_half_gate, pi_gate, \
    early_gate_perfect, late_gate_perfect, H_gate_photon_1, \
    pi_half_inv_gate = gates_state_sec(numb_photons, beta_par, beta_ort, cross_ex)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1 = LC_rotations_photons()
    deltaOH = 0
    Z_rot_S = LC_Z_spin(deltaOH)
    identity = np.array([[1, 0, 0, 0],
                         [0, 1, 0, 0],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]], dtype=np.complex128)

    for i in range(1):
        state_per = gen_box(numb_photons, kappa, ex_perfect, early_gate_perfect, late_gate_perfect, state, C1, C2, H_gate_photon_1, deltaOH,\
                                 Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, Z_rot_S, X_rot_gate_1)

        state, state0, state1 = stab_ancilla_meas(state_per, H_gate_photon_1, identity, "3")
