import networkx as nx
import json
import itertools
import numpy as np

def get_code(G, target_node):
	X = [0] * G.number_of_nodes()
	Z = [0] * G.number_of_nodes()
	S = [[0] * G.number_of_nodes()] * (G.number_of_nodes() - 1)
	count = 0
	for node in G.nodes:
		if node == target_node:
			track = [n for n in range(G.number_of_nodes())]
			neigh = []
			edges = list(G.edges(node))
			target = edges[0][0]
			track.remove(target)
			#Z = Z[:target] + ['X'] + Z[target + 1:]
			X = X[:target] + ['I'] + X[target + 1:]
			neigh = [edge[1] for edge in edges]
			#print(bajs)
			#for edge in edges:
			#       neigh.append(edge[1])
			neigh.sort()
			for idx in neigh:
				track.remove(idx)
				Z = Z[:idx] + ['I'] + Z[idx + 1:]
				X = X[:idx] + ['Z'] + X[idx + 1:]
			nei0 = neigh[0]
			nei1 = neigh[1]
			if nei0 != 0:
				Z = Z[:nei0] + ['X'] + Z[nei0 + 1:]	
				edges = list(G.edges(nei0))
			else:
				Z = Z[:nei1] + ['X'] + Z[nei1 + 1:]
				edges = list(G.edges(nei1))
			neigh_Z = [edge[1] for edge in edges]
			for numb in track:
				X = X[:numb] + ['I'] + X[numb + 1:]
				Z = Z[:numb] + ['I'] + Z[numb + 1:]
			for idx in neigh_Z:
				if idx == 0:
					Z = Z[:idx] + ['I'] + Z[idx + 1:]
				else:
					Z = Z[:idx] + ['Z'] + Z[idx + 1:]
			
			#print(X)
		else:
			track = [n for n in range(G.number_of_nodes())]
			neigh = []
			edges = list(G.edges(node))
			target = edges[0][0]
			track.remove(target)
			S[count] = S[count][:target] + ['X'] + S[count][target + 1:]
			for edge in edges:
				neigh.append(edge[1])
			neigh.sort()
			for idx in neigh:
				track.remove(idx)
				S[count] = S[count][:idx] + ['Z'] + S[count][idx + 1:]
			for numb in track:
				S[count] = S[count][:numb] + ['I'] + S[count][numb + 1:]
			count += 1
	
	new_S = []
	for stab in S:
		for i in range(len(stab)):
			if stab[i] == "Z" and X[i] == "Z":
				new_S.append(stab)
				break
	S = new_S
	#print(S)
	new_S = []
	for stab in S:
		count = 0
		for i in range(len(stab)):
			#count = 0
			if stab[i] == "X" and X[i] == "Z":
				count += 1
		if count == 0:
			new_S.append(stab)		
	
	S = new_S
	#print(S)
	length = 10
	good_matches = []
	while length > 0:
		if len(S) == 0:
			break	
		count = find_matching_stab(S)
		min_len, the_indx = lowest_matching_stab(count)
		good_matches.append(S[the_indx])
		if min_len > 0:
			S_new = []
			full_list = [n for n in range(len(S))]
			full_list.remove(the_indx)
			for rm in count[the_indx]:
				full_list.remove(rm)
			for i in full_list:
				S_new.append(S[i])
			S = S_new
		else:
			del S[the_indx]				
		#print(S)
		#print("GOOD MATCHES {}".format(good_matches))
		length = len(S)
	S = good_matches
	#print(S)
	counter = 0
	count = []	
	for stab in S:
		for i in range(len(stab)):
			if stab[i] == "X" and X[i] == "Z":
				#print(stab)
				count.append(counter)
				#indx = S.index(stab)
				#del S[counter]
				#break
	
		counter += 1
	counter = 0
	for indx in count:
		del S[indx- counter]
		counter += 1

	return X, S, Z	


def find_numb_Z(X, S):
	counter = 0
	for i in range(len(X)):
		if X[i] == "Z":
			counter += 1
	count = 0
	for i in range(len(X)):
		for j in range(len(S)):
			#print(S[j][i])
			#print(X[i])
			#print(counter)
			if X[i] == "Z" and S[j][i] == "Z":
				count +=1
				break
	#print(count)
	if count == counter:
		return True
	else:
		return False

def find_matching_stab(S):
	counter = 0
	count = []
	for stab0 in S:
		counter = 0
		count0 = []
		for stab1 in S:
			for i in range(len(stab0)):
				if (stab0[i] == "X" and stab1[i] == "Z") or (stab0[i] == "Z" and stab1[i] == "X"):
					count0.append(counter)
					break
			counter += 1
		count.append(count0)
	return count


def lowest_matching_stab(count):
	min_len = 10
	indx = 0
	the_indx = 0
	for matches in count:
		if len(matches) < min_len:
			min_len = len(matches)
			the_indx = indx
		indx += 1
	return min_len, the_indx




def get_graph(iter_dict, graph_numb):
	graph_iter_dict = iter_dict[graph_numb] # graph_numb is a string
	key_list = []
	for key in graph_iter_dict:
		key_list.append(key)
	nodes = int(key_list[0]) + 1
	edges = []
	for edge in graph_iter_dict[key_list[0]]["graph"][1]:
		edges.append((edge[0], edge[1]))
	edges = (tuple(edges))
	G = nx.Graph()
	G.add_edges_from(edges)
	return G, nodes

	

if  __name__ == "__main__":
	path = r'/home/lovepettersson/python-quaec/graph_catalouge.json'
	f = open(path)
	the_dict = json.load(f)
	new_dict = {}
	for i in range(4, 10):
		graph, nodes = get_graph(the_dict, str(i))
		X, S, Z = get_code(graph, 0)
		if len(S) != 0:	
			new_dict[str(i)] = [S, X, Z]
			print(i)
			print(S)
			print(X)
			print(Z)
	

	with open('all_4_qubit_graphs.json', 'w') as outfile:
        	json.dump(new_dict, outfile)	
	
