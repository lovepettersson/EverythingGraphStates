import networkx as nx
import numpy as np
import json
from lc_equivalence import check_LCequiv
import cirq
from cirq.ops import CZ, H

# Have to load the json file containing the catalouge of graphs. This should be fixed to be an variable to a
# function, but wrote this code months ago and can't be asked to fix this now. So here we are with an ugly fix.

path = r"C:\Users\Admin\data_8_qubits_no_isomorph.json" # Change this path accordingly
f = open(path)
the_dict = json.load(f)

def counter(graph_number):
    tracker = 0
    for key in the_dict:
        if key == "1":
            tracker += 1
        else:
            class_tracker = 0
            for classes in the_dict[key]:
                for graphs in classes["nodes"]:
                    tracker += 1
                    if tracker == graph_number:
                        idx = graphs["id"]
                        source_list = {}
                        source_list["class"] = class_tracker
                        source_list["key"] = key
                        source_list["source"] = []
                        source_list["target"] = []
                        source_list["equivs"] = []
                        source_list["graph"] = []
                        source_list["graph"].append(classes["nodes"][0]["edges"])
                        source_list["graph"].append(graphs["edges"])
                        running = True
                        while running == True:
                            # if 0 in source_list["source"]:
                            if idx == 0:
                                source_list["target"].append(0)
                                source_list["source"].append(0)
                                source_list["equivs"].append(0)
                                running = False
                            else:
                                source_search = source(classes["links"], idx)
                                # print(classes["links"])
                                source_list["target"].append(source_search[0][0])
                                source_list["source"].append(source_search[1][0])
                                source_list["equivs"].append(source_search[2][0])
                                idx = source_search[1][0]
                class_tracker += 1

    return source_list


def track_LC_seq(link_list, idx, class_tracker, key):
    """ Function to give the full LC-sequence given first id:0 graph"""
    source_list = {}
    source_list["class"] = class_tracker
    source_list["key"] = key
    source_list["source"] = []
    source_list["target"] = []
    source_list["equivs"] = []
    running = True
    while running == True:
        if 0 in source_list["source"]:
            running = False
        else:
            source_search = source(link_list, idx)
            source_list["target"].append(source_search[0][0])
            source_list["source"].append(source_search[1][0])
            source_list["equivs"].append(source_search[2][0])

            idx = source_search[1][0]
    return source_list


def source(link_list, idx):
    """ Function to track given graph down to graph with id:0"""
    target_list = []
    source_list = []
    equiv_list = []
    for targets in link_list:
        if targets["target"] == idx:
            if targets["source"] == 0:
                target_list.append(targets["target"])
                source_list.append(targets["source"])
                equiv_list.append(targets["equivs"][0][0])
            else:
                target_list.append(targets["target"])
                source_list.append(targets["source"])
                equiv_list.append(targets["equivs"][0][0])

    return target_list, source_list, equiv_list


def get_graph(edges):
    """ Function that given this weird list of edges produces the corresponding graph """
    the_edges = []
    for edge in edges:
        the_edges.append(tuple(edge[:-1]))
    graph = nx.Graph()
    graph.add_edges_from(the_edges)
    return graph


def second_search(the_dict, the_key, graph):
    """ Starts the second, third, etc.. round of search. This search is slightly different
    from the first. Hence, the new function..."""
    class_tracker = 0
    for classes in the_dict[str(int(the_key) - 1)]:
        edges_check = (classes["nodes"][0]["edges"])
        graph_check = get_graph(edges_check)
        is_equiv, local_ops = check_LCequiv(graph, graph_check)
        if is_equiv == True:
            adjMat = nx.adjacency_matrix(graph).todense()
            for graphs in classes["nodes"]:
                edges_check = (graphs["edges"])
                graph_check = get_graph(edges_check)
                new_adjMat = nx.adjacency_matrix(graph_check).todense()
                if np.array_equal(adjMat, new_adjMat):
                    the_id = graphs["id"]
                    if the_id == 0:
                        sequence = {"key": str(int(the_key) - 1), "class": class_tracker, "target": [0], "source": [0],
                                    "equivs": [0]}
                        return sequence
                    else:

                        link_list = classes["links"]
                        idx = the_id
                        key = str(int(the_key) - 1)
                        sequence = track_LC_seq(link_list, idx, class_tracker, key)
                        return sequence
        class_tracker += 1





def graph_code(iter_dict, key_list, eps, px, pz, photon_discount):
    """ Function for sanity check if the circuit including the LC-ops actually produces the
    correct graph state"""
    circuit_2 = cirq.Circuit()
    q = cirq.LineQubit.range(int(key_list[0]) + 1)
    circuit_2.append([H(qubit) for qubit in q])
    i = 0
    for edge in iter_dict[key_list[0]]["graph"][1]:
        i += 1
        circuit_2.append([CZ(q[edge[0]], q[edge[1]])])
    pol = cirq.asymmetric_depolarize(
        p_x=px * eps,
        p_y=(1- px- pz) * eps,
        p_z=pz * eps,
    )
    circuit_2.append([pol.on(q[0])])
    pol = cirq.asymmetric_depolarize(
        p_x=px * eps * photon_discount,
        p_y=(1 - px - pz) * eps * photon_discount,
        p_z=pz * eps * photon_discount,
    )
    circuit_2.append([pol.on(qs) for qs in q[1:]])
    dsim = cirq.DensityMatrixSimulator()
    den_matrix = dsim.simulate(circuit_2).final_density_matrix
    return den_matrix



def generation(graph_numb):
    """ Main function called for the generation, includes most else functions"""
    outcome = counter(graph_numb)
    the_key = outcome["key"]
    the_class = outcome["class"]
    id0 = the_dict[the_key][int(the_class)]["nodes"][0]
    edges = id0["edges"]
    graph = get_graph(edges)
    graph.remove_node(int(the_key))
    iter_dict = {}
    iter_dict[str(the_key)] = outcome

    while int(the_key) > 3:
        new_dict = second_search(the_dict, the_key, graph)
        the_key = str(new_dict["key"])
        the_class = int(new_dict["class"])
        iter_dict[str(the_key)] = new_dict
        id0 = the_dict[the_key][the_class]["nodes"][0]
        edges = id0["edges"]
        graph = get_graph(edges)
        graph.remove_node(int(the_key))
    edge_final = the_dict["3"][the_class]["nodes"][0]["edges"]
    graph_final = get_graph(edge_final)
    graph_final.remove_node(3)
    iter_dict["2"] = []
    if graph_final.number_of_edges() == 3:
        iter_dict["2"].append(3)
    elif graph_final.number_of_edges() == 2:
        iter_dict["2"].append(2)

    return iter_dict


def get_it(iter_dict, key_list, eps, px, pz, photon_discount):
    return graph_code(iter_dict, key_list, eps, px, pz, photon_discount)


