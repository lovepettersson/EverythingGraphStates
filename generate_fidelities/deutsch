import numpy as np
from generate_error_inflicted_graphs import photon_rotations, gates_state, photo_gen, basis_change, LC_density, LC_photon, switch, photo_gen_ideal, photo_gen_LC
import cirq
from cirq.ops import CZ, H
import matplotlib.pyplot as plt


def measurement():
   
    qudit_10 = np.array([1, 0, 0, 0], dtype=np.complex128) # qubit 1
    qudit_20 = np.array([0, 0, 1, 0], dtype=np.complex128) # qubit 3
    qudit_30 = np.array([0, 1 / np.sqrt(2), -1 / np.sqrt(2), 0], dtype=np.complex128) # qubit 4
    qudit_40 = np.array([0, 1 / np.sqrt(2), 1 / np.sqrt(2), 0], dtype=np.complex128) # qubit 1

    qudit_11 = np.array([0, 1, 0, 0], dtype=np.complex128) # qubit 2
    qudit_21 = np.array([0, 1, 0, 0], dtype=np.complex128) # qubit 3
    qudit_31 = np.array([0, 1 / np.sqrt(2), 1 / np.sqrt(2), 0], dtype=np.complex128) # qubit 4
    qudit_41 = np.array([0, 1 / np.sqrt(2), -1 / np.sqrt(2), 0], dtype=np.complex128) # qubit 1

    base01 = np.kron(np.kron(np.kron(qudit_10, qudit_20), qudit_30), qudit_40)
    base00 = np.kron(np.kron(np.kron(qudit_10, qudit_21), qudit_30), qudit_40)
    base11 = np.kron(np.kron(np.kron(qudit_10, qudit_20), qudit_30), qudit_41)
    base10 = np.kron(np.kron(np.kron(qudit_10, qudit_21), qudit_30), qudit_41)

    return base00, base01, base10, base11


def measurement_balanced():
    
    qudit_10 = np.array([1 / np.sqrt(2), -1j / np.sqrt(2), 0, 0], dtype=np.complex128) # qubit 2
    qudit_20 = np.array([0, 1, 0, 0], dtype=np.complex128) # qubit 3
    qudit_30 = np.array([0, 1 / np.sqrt(2), -1 / np.sqrt(2), 0], dtype=np.complex128) # qubit 4
    qudit_40 = np.array([0, 1 / np.sqrt(2), 1j / np.sqrt(2), 0], dtype=np.complex128) # qubit 1

    qudit_11 = np.array([1 / np.sqrt(2), 1j / np.sqrt(2), 0, 0], dtype=np.complex128)  # qubit 2
    qudit_21 = np.array([0, 0, 1, 0], dtype=np.complex128)  # qubit 3
    qudit_31 = np.array([0, 1 / np.sqrt(2), 1 / np.sqrt(2), 0], dtype=np.complex128)  # qubit 4
    qudit_41 = np.array([0, 1 / np.sqrt(2), -1j / np.sqrt(2), 0], dtype=np.complex128)  # qubit 1

    ## change to qudit11 and qudit31 for s_2 = 1 and s_4 = 1 respectivley
    base00 = np.kron(np.kron(np.kron(qudit_10, qudit_20), qudit_30), qudit_40)
    base01 = np.kron(np.kron(np.kron(qudit_10, qudit_21), qudit_30), qudit_40)
    base10 = np.kron(np.kron(np.kron(qudit_10, qudit_20), qudit_30), qudit_41)
    base11 = np.kron(np.kron(np.kron(qudit_10, qudit_21), qudit_30), qudit_41)

    return base00, base01, base10, base11

def gen_cirq_graph():
    q = cirq.LineQubit.range(4)
    circuit = cirq.Circuit()
    circuit.append([H(q[0]), H(q[1]), H(q[2]), H(q[3])])
    circuit.append([CZ(q[0], q[1]), CZ(q[1], q[2]), CZ(q[0], q[3])])
    result = cirq.Simulator().simulate(circuit).final_state_vector
    return result


def generate_line(numb_photons):
    ex, early_gate, late_gate, density_matrix, basis, H_gate_photon_1, H_gate_photon_2, H_gate_photon_3 = gates_state(
        numb_photons, 0.992, 0.072, 1.7 * 10 ** (-2), density=True)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin = photon_rotations()

    ### GENERATE TWO PHOTONS
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)

    ### DO FIRST LOCAL COMPLEMENTATION ON SPIN
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = LC_density(density_matrix, numb_photons)
    density_matrix = np.matmul(np.matmul(Z_rot_gate_1, density_matrix), np.conjugate(Z_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### GENERATE LAST PHOTON
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### LAST LC ON PHOTON 1
    density_matrix = np.matmul(np.matmul(X_rot_gate_1, density_matrix), np.conjugate(X_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_spin, density_matrix), np.conjugate(Z_rot_spin.transpose()))

    return density_matrix


def generate_line_inv(numb_photons):
    ex, early_gate, late_gate, density_matrix, basis, H_gate_photon_1, H_gate_photon_2, H_gate_photon_3 = gates_state(
        numb_photons, 0.992, 0.072, 1.7 * 10 ** (-2), density=True)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin = photon_rotations()

    ### GENERATE TWO PHOTONS
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = photo_gen_LC(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)

    ### DO FIRST LOCAL COMPLEMENTATION ON SPIN
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(Z_rot_gate_1, density_matrix), np.conjugate(Z_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### GENERATE LAST PHOTON
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### LAST LC ON PHOTON 1
    density_matrix = np.matmul(np.matmul(X_rot_gate_1, density_matrix), np.conjugate(X_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_spin, density_matrix), np.conjugate(Z_rot_spin.transpose()))

    return density_matrix



def generate_ideal_line(numb_photons):
    ex, early_gate, late_gate, X_full_perfect, X_half_perfect, state, H_gate_photon_1, H_gate_photon_2, H_gate_photon_3 = gates_state(
        numb_photons, 1, 0, 0, density=False)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin = photon_rotations()

    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)
    v, state = switch(state, numb_photons)
    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)  
    v, state = switch(state, numb_photons)
    v, state = switch(state, numb_photons)
    state = LC_photon(state, X_half_perfect)

    state = np.matmul(Z_rot_gate_1, state)
    state = np.matmul(Z_rot_gate_2, state)
    v, state = switch(state, numb_photons)
    v, state = switch(state, numb_photons)

    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)
    v, state = switch(state, numb_photons)

    state = np.matmul(X_rot_gate_1, state)
    state = np.matmul(Z_rot_gate_2, state)
    state = np.matmul(Z_rot_spin, state)

    return state

if __name__ == "__main__":
    
    #density_matrix = generate_line_inv(3) # with inv x-rot instead of LC-x on spin
    density_matrix = generate_line(3)
    base = measurement_balanced()
    
    fid00 = np.matmul(np.matmul(np.conjugate(base[0]).transpose(), density_matrix), base[0])
    fid01 = np.matmul(np.matmul(np.conjugate(base[1]).transpose(), density_matrix), base[1])
    fid10 = np.matmul(np.matmul(np.conjugate(base[2]).transpose(), density_matrix), base[2])
    fid11 = np.matmul(np.matmul(np.conjugate(base[3]).transpose(), density_matrix), base[3])

    print(fid00, fid01, fid10, fid11)
    print((fid00 + fid01 + fid10 + fid11) * 4)

    x = (abs(fid11) * 4, abs(fid01) * 4, abs(fid10) * 4, abs(fid00) * 4)
    y = ("|11>", "|01>", "|10>", "|00>")
    plt.bar(y, x, 0.4, align='center')
    plt.ylabel('Probability')
    plt.title(r'Constant function with $s_2 = 0, s_4 = 0$')
    plt.show()
