import numpy as np
from scipy.integrate import complex_ode

global deltaOH
deltaOH = 0

def rho_11(rabi, T_r, kappa):
    """ Analytic solution for excited state population without deltaOH"""
    rabi_tilde = np.sqrt(4 * rabi ** 2 - kappa ** 2)
    func = 1/2 * (1 - np.exp(-(3/2) * (T_r * kappa)) * (np.cos(rabi_tilde * T_r / 2) - (kappa / rabi) * np.sin(rabi_tilde * T_r / 2)))
    return func
#print(rho_11(np.pi/7, 7, 0.021))

def f(t, y):
    kappa = 0.0021
    rabi = np.pi / 7
    rho00 = y[0]
    rho01 = y[1]
    rho10 = y[2]
    rho11 = y[3]
    #deltaOH = 0
    d1 = kappa * (rho11 - rho00) + 1j * (rabi / 2) * (rho01 - rho10)
    d2 = 1j * (rabi / 2) * (rho00 - rho11) - (kappa - 1j * deltaOH) * rho01
    d3 = 1j * (rabi / 2) * (rho11 - rho00) - (kappa + 1j * deltaOH) * rho10
    d4 = kappa * (rho00 - rho11) + 1j * (rabi / 2) * (rho10 - rho01)
    return [d1, d2, d3, d4]


def f_inv(t, y):
    kappa = 0.0021
    rabi = np.pi / 7
    rho00 = y[0]
    rho01 = y[1]
    rho10 = y[2]
    rho11 = y[3]
    #deltaOH = 0
    d1 = kappa * (rho11 - rho00) + -1j * (rabi / 2) * (rho01 - rho10)
    d2 = -1j * (rabi / 2) * (rho00 - rho11) - (kappa - 1j * deltaOH) * rho01
    d3 = -1j * (rabi / 2) * (rho11 - rho00) - (kappa + 1j * deltaOH) * rho10
    d4 = kappa * (rho00 - rho11) - 1j * (rabi / 2) * (rho10 - rho01)
    return [d1, d2, d3, d4]


def gen_rot_inv(t1, y0):
    t0 = 0
    r = complex_ode(f_inv)
    r.set_initial_value(y0, t0)
    dt = 0.01
    sol = np.array([], dtype=np.complex128)
    t   = np.array([], dtype=np.complex128)
    sol0 = []
    while r.successful() and r.t <= t1:
        t = np.append(t, r.t+dt)
        sol = np.append(sol, r.integrate(r.t+dt))
        sol0.append(r.integrate(r.t + dt))

    A1 = []
    A2 = []
    A3 = []
    A4 = []
    for i in range(len(sol0)):
        A1.append(sol0[i][0])
        A2.append(sol0[i][1])
        A3.append(sol0[i][2])
        A4.append(sol0[i][3])

    output = [[A1[-1], A2[-1]], [A3[-1], A4[-1]]]
    Z_rot = np.zeros([2, 2], dtype=np.complex128)
    square_root = 1 / np.sqrt(2)
    Z_rot[0][0] = (1 + 1j) * square_root
    Z_rot[1][1] = (1 - 1j) * square_root
    step0 = np.matmul(Z_rot, output)
    step1 = np.matmul(step0, np.conjugate(Z_rot)) # if you want a R_y rot instead
    return step1, output


def gen_rot(t1, y0):
    t0 = 0
    r = complex_ode(f)
    r.set_initial_value(y0, t0)
    dt = 0.1
    sol = np.array([], dtype=np.complex128)
    t   = np.array([], dtype=np.complex128)
    sol0 = []
    while r.successful() and r.t <= t1:
        t = np.append(t, r.t+dt)
        sol = np.append(sol, r.integrate(r.t+dt))
        sol0.append(r.integrate(r.t + dt))

    A1 = []
    A2 = []
    A3 = []
    A4 = []
    for i in range(len(sol0)):
        A1.append(sol0[i][0])
        A2.append(sol0[i][1])
        A3.append(sol0[i][2])
        A4.append(sol0[i][3])

    output = [[A1[-1], A2[-1]], [A3[-1], A4[-1]]]
    Z_rot = np.zeros([2, 2], dtype=np.complex128)
    square_root = 1 / np.sqrt(2)
    Z_rot[0][0] = (1 + 1j) * square_root
    Z_rot[1][1] = (1 - 1j) * square_root
    step0 = np.matmul(Z_rot, output)
    step1 = np.matmul(step0, np.conjugate(Z_rot)) # if you want a R_y rot instead
    return step1, output

def gen_with_deltaOH(time):
    mean00 = []
    mean01 = []
    mean10 = []
    mean11 = []

    norm = np.random.normal(0, np.sqrt(2) / 23.2, 100)
    for OH in norm:
        deltaOH = OH
        outcome = gen_rot(time, y0=np.array([1, 0, 0, 0], dtype=np.complex128))
        mean00.append(outcome[1][0][0])
        mean01.append(outcome[1][0][1])
        mean10.append(outcome[1][1][0])
        mean11.append(outcome[1][1][1])

    return (np.mean(mean00), np.mean(mean01), np.mean(mean10), np.mean(mean11))

