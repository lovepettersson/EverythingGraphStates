import numpy as np
import matplotlib.pyplot as plt
from generate_error_inflicted_graphs import photo_gen, basis_change, LC_photon, LC_density, photo_gen_ideal
from gates_and_basis_change import switch

def photon_rotations():
    square_root = 1 / (2 ** (1 / 2))
    rot_matrix = np.array([[1, 0, 0, 0],
                           [0, (1 + 1j) * square_root, 0, 0],
                           [0, 0, (1 - 1j) * square_root, 0],
                           [0, 0, 0, 1],
                           ])
    identity = np.array([[1, 0, 0, 0],
                         [0, 1, 0, 0],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]], dtype=np.complex128)
    Z_rot_gate_1 = np.kron(np.kron(np.kron(identity, rot_matrix), identity), identity)
    Z_rot_gate_2 = np.kron(np.kron(np.kron(identity, identity), rot_matrix), identity)
    Z_rot_gate_3 = np.kron(np.kron(np.kron(identity, identity), identity), rot_matrix)

    rot_matrix = np.array([[1, 0, 0, 0],
                           [0, 1 * square_root, -1j * square_root, 0],
                           [0, -1j * square_root, 1 * square_root, 0],
                           [0, 0, 0, 1],
                           ])
    X_rot_gate_1 = np.kron(np.kron(np.kron(identity, rot_matrix), identity), identity)

    rot_matrix = np.array([[(1 + 1j) * square_root, 0, 0, 0],
                           [0, (1 - 1j) * square_root, 0, 0],
                           [0, 0, 1, 0],
                           [0, 0, 0, 1],
                           ])
    Z_rot_spin = np.kron(np.kron(np.kron(rot_matrix, identity), identity), identity)

    return Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin

def generate_box(numb_photons):
    ex, early_gate, late_gate, density_matrix, basis, H_gate_photon_1, H_gate_photon_2, H_gate_photon_3 = gates_state(
        numb_photons, 0.992, 0.072, 1.7 * 10 ** (-2), density=True)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin = photon_rotations()

    ### GENERATE TWO PHOTONS
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)

    ### DO FIRST LOCAL COMPLEMENTATION ON SPIN
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = LC_density(density_matrix, numb_photons)
    density_matrix = np.matmul(np.matmul(Z_rot_gate_1, density_matrix), np.conjugate(Z_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### GENERATE LAST PHOTON
    density_matrix = photo_gen(density_matrix, numb_photons, ex, early_gate, late_gate)
    density_matrix = np.matmul(np.matmul(H_gate_photon_1.transpose(), density_matrix), H_gate_photon_1)
    density_matrix = basis_change(density_matrix, basis[0], numb_photons, ex, early_gate, late_gate)

    ### DO SECOND LOCAL COMPLEMENTATION ON SPIN
    density_matrix = LC_density(density_matrix, numb_photons)
    density_matrix = np.matmul(np.matmul(Z_rot_gate_1, density_matrix), np.conjugate(Z_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_2, density_matrix), np.conjugate(Z_rot_gate_2.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_3, density_matrix), np.conjugate(Z_rot_gate_3.transpose()))

    ### LAST LC ON PHOTON 1
    density_matrix = np.matmul(np.matmul(X_rot_gate_1, density_matrix), np.conjugate(X_rot_gate_1.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_gate_3, density_matrix), np.conjugate(Z_rot_gate_3.transpose()))
    density_matrix = np.matmul(np.matmul(Z_rot_spin, density_matrix), np.conjugate(Z_rot_spin.transpose()))

    return density_matrix


def generate_ideal_box(numb_photons):
    ex, early_gate, late_gate, X_full_perfect, X_half_perfect, state, H_gate_photon_1, H_gate_photon_2, H_gate_photon_3 = gates_state(
        numb_photons, 1, 0, 0, density=False)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1, Z_rot_spin = photon_rotations()
    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)
    v, state = switch(state, numb_photons)
    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)  ## remeber now photon two is at position one..
    v, state = switch(state, numb_photons)
    v, state = switch(state, numb_photons)
    state = LC_photon(state, X_half_perfect)

    state = np.matmul(Z_rot_gate_1, state)
    state = np.matmul(Z_rot_gate_2, state)
    v, state = switch(state, numb_photons)
    v, state = switch(state, numb_photons)

    state = photo_gen_ideal(state, ex, early_gate, late_gate, X_full_perfect)
    state = np.matmul(H_gate_photon_1, state)
    v, state = switch(state, numb_photons)

    state = LC_photon(state, X_half_perfect)
    state = np.matmul(Z_rot_gate_1, state)
    state = np.matmul(Z_rot_gate_2, state)
    state = np.matmul(Z_rot_gate_3, state)

    state = np.matmul(X_rot_gate_1, state)
    state = np.matmul(Z_rot_gate_3, state)
    state = np.matmul(Z_rot_spin, state)

    return state


def measurement(ang1, ang2):
    # SPIN = qudit_1, PHOTON_1 = qudit_2, etc....
    qudit_1 = np.array([1 / np.sqrt(2), np.exp(1j*ang1) / np.sqrt(2), 0, 0], dtype=np.complex128)
    qudit_2 = np.array([0, 1 / np.sqrt(2), np.exp(1j*ang2) / np.sqrt(2), 0], dtype=np.complex128)
    qudit_1_minus = np.array([1 / np.sqrt(2), -np.exp(1j * ang1) / np.sqrt(2), 0, 0], dtype=np.complex128)
    qudit_2_minus = np.array([0, 1 / np.sqrt(2), -np.exp(1j * ang2) / np.sqrt(2), 0], dtype=np.complex128)
    first_list = [qudit_1, qudit_1_minus]
    qudit_3 = np.array([0, 0, 1, 0], dtype=np.complex128)
    qudit_4 = np.array([0, 0, 1, 0], dtype=np.complex128)
    qudit_3_zero = np.array([0, 1, 0, 0], dtype=np.complex128)
    qudit_4_zero = np.array([0, 1, 0, 0], dtype=np.complex128)

    Z_H = np.array([[1, 0, 0, 0],
                         [0, 1 / (2 ** (1 / 2)), 1 / (2 ** (1 / 2)), 0],
                         [0, -1 / (2 ** (1 / 2)), 1 / (2 ** (1 / 2)), 0],
                         [0, 0, 0, 1],
                         ])


    qudit_3 = np.matmul(Z_H, qudit_3)
    qudit_4 = np.matmul(Z_H, qudit_4)
    qudit_3_zero = np.matmul(Z_H, qudit_3_zero)
    qudit_4_zero = np.matmul(Z_H, qudit_4_zero)
  
    # s_2=0, s_4=0, i.e no pauli errors
    base11 = np.kron(np.kron(np.kron(qudit_1, qudit_2), qudit_3), qudit_4)
    base00 = np.kron(np.kron(np.kron(qudit_1, qudit_2), qudit_3_zero), qudit_4_zero)
    base01 = np.kron(np.kron(np.kron(qudit_1, qudit_2), qudit_3_zero), qudit_4)
    base10 = np.kron(np.kron(np.kron(qudit_1, qudit_2), qudit_3), qudit_4_zero)

    basis0 = [base00, base01, base10, base11]
    '''
    # s_4=1, s_2=0, i.e pauli error on qubit 4(qudit 2 in our case)
    base01 = np.kron(np.kron(np.kron(qudit_1, qudit_2_minus), qudit_3), qudit_4)
    base10 = np.kron(np.kron(np.kron(qudit_1, qudit_2_minus), qudit_3_zero), qudit_4_zero)
    base11 = np.kron(np.kron(np.kron(qudit_1, qudit_2_minus), qudit_3_zero), qudit_4)
    base00 = np.kron(np.kron(np.kron(qudit_1, qudit_2_minus), qudit_3), qudit_4_zero)

    basis1 = [base00, base01, base10, base11]

    # s_4=0, s_2=1, i.e pauli error on qubit 4(qudit 2 in our case)
    base10 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2), qudit_3), qudit_4)
    base01 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2), qudit_3_zero), qudit_4_zero)
    base00 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2), qudit_3_zero), qudit_4)
    base11 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2), qudit_3), qudit_4_zero)

    basis2 = [base00, base01, base10, base11]

    # s_4=1, s_2=1, i.e pauli error on qubit 4(qudit 2 in our case)
    base00 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2_minus), qudit_3), qudit_4)
    base11 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2_minus), qudit_3_zero), qudit_4_zero)
    base10 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2_minus), qudit_3_zero), qudit_4)
    base01 = np.kron(np.kron(np.kron(qudit_1_minus, qudit_2_minus), qudit_3), qudit_4_zero)

    basis3 = [base00, base01, base10, base11]
    '''
 
    return basis0 


if __name__ == "__main__":

    numb_photons = 3
    kappa = 0.021
    beta_par = 0.992
    beta_ort = 0.072
    cross_ex =  0.1 #1.7 * 10 ** (-2)

    # Get matrices
    ex, ex_perfect, early_gate, late_gate, state, C1, C2, pi_half_gate, pi_gate, \
    early_gate_perfect, late_gate_perfect, H_gate_photon_1, \
    pi_half_inv_gate = gates_state_sec(numb_photons, beta_par, beta_ort, cross_ex)
    Z_spin_perfect = LC_Z_spin(0)
    Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, X_rot_gate_1 = LC_rotations_photons()

    ideal = gen_box_ideal(numb_photons, ex_perfect, early_gate_perfect, late_gate_perfect, state, pi_half_gate,
                           pi_gate,
                           H_gate_photon_1, Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, Z_spin_perfect, X_rot_gate_1, pi_half_inv_gate)

    # Get measurement basis
    basis_states = measurement(0, 0)

    collection = []
    fid00 = []
    fid01 = []
    fid10 = []
    fid11 = []
    for j in range(10):
        density_matrix = 0
        for i in range(1000):
            deltaOH = np.random.normal(0, np.sqrt(2) / 23.2)
            Z_rot_S = LC_Z_spin(deltaOH)
            rot_state = gen_box(numb_photons, kappa, ex, early_gate, late_gate, state, C1, C2, H_gate_photon_1, deltaOH,\
                                Z_rot_gate_1, Z_rot_gate_2, Z_rot_gate_3, Z_rot_S, X_rot_gate_1)
            density_matrix += np.outer(rot_state, np.conjugate(rot_state).transpose()) / 1000
            if i % 10 == 0:
                print("At step {} in the loop".format(i))
        fd00 = np.matmul(np.matmul(np.conjugate(basis_states[0]).transpose(), density_matrix), basis_states[0])
        fd01 = np.matmul(np.matmul(np.conjugate(basis_states[1]).transpose(), density_matrix), basis_states[1])
        fd10 = np.matmul(np.matmul(np.conjugate(basis_states[2]).transpose(), density_matrix), basis_states[2])
        fd11 = np.matmul(np.matmul(np.conjugate(basis_states[3]).transpose(), density_matrix), basis_states[3])
        norm = fd00 + fd01 + fd10 + fd11
        fid00.append(fd00 / norm)
        fid01.append(fd01 / norm)
        fid10.append(fd10 / norm)
        fid11.append(fd11 / norm)
  
    print("mean 00 prob is {}, mean 01 prob is {}, mean 10 prob is {} and mean 11 prob is {}".format(np.mean(fid00),\
                                                                                                     np.mean(fid01),\
                                                                                                     np.mean(fid10),\
                                                                                                     np.mean(fid11)))

    print("std 00 prob is {}, std 01 prob is {}, std 10 prob is {} and std 11 prob is {}".format(np.std(fid00), \
                                                                                                     np.std(fid01), \
                                                                                                     np.std(fid10), \
                                                                                                     np.std(fid11)))
    x = (abs(np.mean(fid00)), abs(np.mean(fid01)), abs(np.mean(fid10)), abs(np.mean((fid11))))
    error = (np.std(fid00), np.std(fid01), np.std(fid10), np.std(fid11))
    print(x)
    y = ("|00>", "|01>", "|10>", "|11>")
    plt.bar(y, x, 0.4, yerr=error, align='center', alpha=0.5, ecolor='black', capsize=10)
    plt.ylabel('Probability')
    plt.title(r'$\alpha = 0, \beta = 0$')
    plt.show()



