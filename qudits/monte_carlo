import numpy as np
import cirq
import json
import matplotlib.pyplot as plt

from generation.generate_circuit import generation, get_graph
from gates import QuditDepGate, QuditLatePhoton, QuditEarlyPhoton, QuditExcGate, QuditPiHalfGate, QuditPiGate, QuditXRotGate, QuditZRotGate, QuditZPhRotGate, QuditXPhRotGate, QuditHPhGate, QuditCZPhoton


def local_complement(target, neigh, circuit, delta, photon = True):
    """ Function to perform LC in the circuit given the target and its neighbours"""
    Xphoton = QuditXPhRotGate()
    XSpin = QuditXRotGate(delta)
    Zphoton = QuditZPhRotGate()
    ZSpin = QuditZRotGate(delta)
    if photon == True:
        circuit.append([Xphoton.on(target)])
    else:
        circuit.append([XSpin.on(target)])
    for key in neigh:
        if neigh[key] == "photon":
            circuit.append([Zphoton.on(key)])
        elif neigh[key] == "spin":
            circuit.append([ZSpin.on(key)])





def simulate(normal_dist, error, target):
    density_matrix = []
    for value in normal_dist:
        if target == "delta0":
            outcome = print_circuit(0.98, 0.02, error, 0, value)
            density_matrix.append(outcome)
        elif target == "delta_small":
            outcome = print_circuit(0.98, 0.02, 0, error, value)
            density_matrix.append(outcome)


    return density_matrix

def print_circuit(beta_par, beta_ort, delta0, delta_small, deltaOH, noise=True):
    """ Function that creates the circuit that builds the graph state from scratch"""
    q_0 = cirq.LineQid(0, dimension=4)
    q_1 = cirq.LineQid(1, dimension=4)
    q_2 = cirq.LineQid(2, dimension=4)
    q_3 = cirq.LineQid(3, dimension=4)
    q_4 = cirq.LineQid(4, dimension=4)
    q_5 = cirq.LineQid(5, dimension=4)
    q_6 = cirq.LineQid(6, dimension=4)
    q_7 = cirq.LineQid(7, dimension=4)
    q = [q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7]
    this_gate6 = QuditDepGate(deltaOH)
    circuit = cirq.Circuit()
    this_gate1 = QuditPiHalfGate(delta_small)
    circuit.append([this_gate1.on(q[0])])
    if iter_dict["2"][0] == 3:
        photon_gen(q[0], q[1], circuit, beta_par, beta_ort, delta0, delta_small)
        photon_gen(q[0], q[2], circuit, beta_par, beta_ort, delta0, delta_small)
        local_complement(q[0], {q[1]: "photon", q[2]: "photon"}, circuit, delta_small, photon=False)
    else:
        photon_gen(q[0], q[1], circuit, beta_par, beta_ort, delta0, delta_small)
        photon_gen(q[0], q[2], circuit, beta_par, beta_ort, delta0, delta_small)
    for i in reversed(key_list):
        if int(i) == 2:
            continue
        else:
            if iter_dict[i]["target"][0] == 0 and iter_dict[i]["source"][0] == 0:
                photon_gen(q[0], q[int(i)], circuit, beta_par, beta_ort, delta0, delta_small)
            else:
                photon_gen(q[0], q[int(i)], circuit, beta_par, beta_ort, delta0, delta_small)
                the_class = iter_dict[i]["class"]
                length = [n for n in range(len(iter_dict[i]["equivs"]))]
                for j in reversed(length):
                    if iter_dict[i]["target"][j] == 0 and iter_dict[i]["source"][j] == 0:
                        continue
                        #print("found one")
                    else:
                        LC_node = iter_dict[i]["source"][j]
                        edge_final = the_dict[i][the_class]["nodes"][LC_node]["edges"]
                        graph_final = get_graph(edge_final)
                        target = iter_dict[i]["equivs"][j]
                        neigbours = [n for n in graph_final.neighbors(target)]
                        neig = {}
                        for neb in neigbours:
                            if neb == 0:
                                neig[q[neb]] = "spin"
                            else:
                                neig[q[neb]] = "photon"
                        if target == 0:
                            local_complement(q[target], neig, circuit, delta_small, photon=True)
                        else:
                            local_complement(q[target], neig, circuit, delta_small, photon=False)
    if noise == True:
        circuit.append([this_gate6.on(q[0])])

    result = cirq.Simulator().simulate(circuit).final_state_vector
    return result

def photon_gen(q0, q1, circuit, beta_par, beta_ort, delta0, delta_small):
    this_gate0 = QuditEarlyPhoton(beta_par, beta_ort)
    this_gate2 = QuditExcGate(delta0)
    this_gate3 = QuditPiGate(delta_small)
    this_gate4 = QuditLatePhoton(beta_par, beta_ort)
    this_gate5 = QuditHPhGate()
    circuit.append([this_gate2.on(q0), this_gate0.on(q0, q1), this_gate3.on(q0),
            this_gate2.on(q0),
            this_gate4.on(q0, q1), this_gate3.on(q0), this_gate5.on(q1)])


if __name__ == "__main__":
    path = r"C:\Users\Admin\data_8_qubits_no_isomorph.json"
    f = open(path)
    the_dict = json.load(f)
    # Generate the LC-sequence for given graph from catalouge
    iter_dict = generation(602)
    key_list = []
    for key in iter_dict:
        key_list.append(key)

    #result0 = print_circuit(1, 0, 0, 0, 0, noise=False)
    #result1 = print_circuit(0.98, 0.02, 0.02, 0.02, 0.02, noise=True)
    #print(abs(np.dot(np.conjugate(result0), result1))**2)
    
    error = np.linspace(0, 0.2, 20)
    normal_dist = np.random.normal(0, np.pi / 12, 1000)
    fidelity = []
    for err in error:
        density_matrix = simulate(normal_dist, err, "delta0")
        ideal_state = print_circuit(1, 0, 0, 0, 0, noise=False)
        monte_sim = []
        for state in density_matrix:
            overlap = np.dot(np.conjugate(ideal_state), state)
            overlap_abs = abs(overlap) ** 2
            monte_sim.append(overlap_abs)
        fidelity.append(sum(monte_sim) / len(monte_sim))

    plt.plot(error, fidelity)
    plt.xlabel("error")
    plt.ylabel("fidelity")
    plt.show()

