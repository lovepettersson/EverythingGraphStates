import numpy as np


def spin_unitary(phi, rabi, time, deltaOH):
    # IT SHOULD BE  1/4
    norm = 1 / np.sqrt((rabi) ** 2 + (deltaOH ** 2))
    theta = (time / 2) / norm
    identity_part = np.array([[1 * np.cos(theta), 0, 0, 0],
                              [0, 1 * np.cos(theta), 0, 0],
                              [0, 0, 1 / 4, 0],
                              [0, 0, 0, 1 / 4]])

    x_part = np.array([[0, 1 * (-1j) * np.sin(theta) * rabi*np.cos(phi) * norm, 0, 0],
                       [1 * (-1j) * np.sin(theta) * rabi*np.cos(phi) * norm, 0, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]])

    y_part = np.array([[0, -1j * (-1j) * np.sin(theta) * rabi*np.sin(phi) * norm, 0, 0],
                       [1j * (-1j) * np.sin(theta) * rabi*np.sin(phi) * norm, 0, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]])

    z_part = np.array([[1 * (-1j) * np.sin(theta) * (-deltaOH) * norm, 0, 0, 0],
                       [0, -1 * (-1j) * np.sin(theta) * (-deltaOH) * norm, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]]
                                  )

    rotation_unitary = identity_part + y_part + x_part + z_part
    return rotation_unitary



def spin_inverse_unitary(phi, rabi, time, deltaOH):
    norm = 1 / np.sqrt((rabi) ** 2 + (deltaOH ** 2))
    theta = (time / 2) / norm
    identity_part = np.array([[1 * np.cos(theta), 0, 0, 0],
                              [0, 1 * np.cos(theta), 0, 0],
                              [0, 0, 1 / 4, 0],
                              [0, 0, 0, 1 / 4]])

    x_part = np.array([[0, 1 * (1j) * np.sin(theta) * rabi*np.cos(phi) * norm, 0, 0],
                       [1 * (1j) * np.sin(theta) * rabi*np.cos(phi) * norm, 0, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]])

    y_part = np.array([[0, -1j * (1j) * np.sin(theta) * rabi*np.sin(phi) * norm, 0, 0],
                       [1j * (1j) * np.sin(theta) * rabi*np.sin(phi) * norm, 0, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]])

    z_part = np.array([[1 * (1j) * np.sin(theta) * (-deltaOH) * norm, 0, 0, 0],
                       [0, -1 * (1j) * np.sin(theta) * (-deltaOH) * norm, 0, 0],
                       [0, 0, 1 / 4, 0],
                       [0, 0, 0, 1 / 4]]
                                  )

    rotation_unitary = identity_part + y_part + x_part + z_part
    return rotation_unitary





def prob_dist(kappa):
    t_f = np.random.exponential(1/kappa)
    return t_f


def spin_flip_op(kappa):
    zero_to_one = np.array([[0, 0, 0, 0],
                            [np.sqrt(kappa), 0, 0, 0],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0]])

    one_to_zero = np.array([[0, np.sqrt(kappa), 0, 0],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0]])

    return zero_to_one, one_to_zero



def rot_uni_arb(t_dur, state_evolved, kappa, numb_photons, C1, C2, deltaOH, psi_s):
    t_now = 0
    psi = state_evolved
    iden = np.array([[1, 0, 0, 0],
                     [0, 1, 0, 0],
                     [0, 0, 1, 0],
                     [0, 0, 0, 1]])

    while t_now < t_dur:
        t_f = prob_dist(kappa)
        if t_now + t_f >= t_dur:
            pulse = spin_unitary(psi_s, np.pi / 7, t_dur - t_now, deltaOH) # Change 0 to pi/ 2 for y-rot
            rot = pulse
            for i in range(numb_photons):
                rot = np.kron(rot, iden)
            psi = np.matmul(rot, psi)
            break
        else:
            pulse = spin_unitary(psi_s, np.pi / 7, t_f, deltaOH) # Change 0 to pi/ 2 for y-rot
            rot = pulse
            for i in range(numb_photons):
                rot = np.kron(rot, iden)
            psi = np.matmul(rot, psi)
            p1 = np.linalg.norm(np.matmul(C1, psi)) ** 2
            p2 = np.linalg.norm(np.matmul(C2, psi)) ** 2
            ### EXACTLY LIKE MARTIN
            if np.random.uniform() < p1:
                psi = np.matmul(C1, psi) / (np.sqrt(p1))
            else:
                psi = np.matmul(C2, psi) / (np.sqrt((p2)))

            t_now += t_f
    return psi


def rot_uni_inv(t_dur, state_evolved, kappa, numb_photons, C1, C2, deltaOH):
    t_now = 0
    psi = state_evolved
    #deltaOH = np.random.normal(0, np.sqrt(2) / 23.2)
    iden = np.array([[1, 0, 0, 0],
                     [0, 1, 0, 0],
                     [0, 0, 1, 0],
                     [0, 0, 0, 1]])

    while t_now < t_dur:
        t_f = prob_dist(kappa)
        if t_now + t_f >= t_dur:
            pulse = spin_inverse_unitary(0, np.pi / 7, t_dur - t_now, deltaOH) # Change 0 to pi/ 2 for y-rot
            rot = pulse
            for i in range(numb_photons):
                rot = np.kron(rot, iden)
            psi = np.matmul(rot, psi)
            break
        else:
            pulse = spin_inverse_unitary(0, np.pi / 7, t_f, deltaOH) # Change 0 to pi/ 2 for y-rot
            rot = pulse
            for i in range(numb_photons):
                rot = np.kron(rot, iden)
            psi = np.matmul(rot, psi)
            p1 = np.linalg.norm(np.matmul(C1, psi)) ** 2
            if np.random.uniform() < p1:
                psi = np.matmul(C1, psi) / (np.sqrt(p1))
            else:
                psi = np.matmul(C2, psi) / (np.sqrt((1 - p1)))

            t_now += t_f
    return psi
