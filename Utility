import numpy as np
from spin_rot import spin_unitary, spin_inverse_unitary


def LC(state, ops, include_X=False):
    """
    :param state: current state
    :param ops: list of operations to apply, ops[0] is the X-rot and ops[1] are the Z-rots
    :return: new state after LC-op applied
    """
    if include_X == False:
        # state = np.matmul(ops[0], state)
        for i in range(len(ops[1])):
            state = np.matmul(ops[1][i], state)
    else:
        state = np.matmul(ops[0], state)
        for i in range(len(ops[1])):
            state = np.matmul(ops[1][i], state)

    return state


def Z_rots(numb_photons, deltaOH):
    """

    :param numb_photons: number of photons
    :param deltaOH: deltaOH.... gates ahve to be sampled every monte step...
    :return: A list of Z-pi-half rots for all qudits, starting with spin.
    """
    Z = []
    square_root = 1 / (2 ** (1 / 2))
    rot_matrix = np.array([[1, 0, 0, 0],
                           [0, (1 + 1j) * square_root, 0, 0],
                           [0, 0, (1 - 1j) * square_root, 0],
                           [0, 0, 0, 1],
                           ])
    identity = np.array([[1, 0, 0, 0],
                         [0, 1, 0, 0],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]], dtype=np.complex64) # dtype=np.complex128

    Z_rot_spin = np.conjugate(spin_inverse_unitary(0, 0, np.pi / 2, 1 + deltaOH))
    for i in range(numb_photons):
        Z_rot_spin = np.kron(Z_rot_spin, identity)
    Z.append(Z_rot_spin)
    for i in range(numb_photons):
        if i == 0:
            op = np.kron(identity, rot_matrix)
        else:
            op = np.kron(identity, identity)
        for j in range(1, numb_photons):
            if i == j:
                op = np.kron(op, rot_matrix)
            else:
                op = np.kron(op, identity)
        Z.append(op)
    return Z


def X_rots(numb_photons, deltaOH):
    """

    :param numb_photons: number of photons
    :param deltaOH: deltaOH.... gates ahve to be sampled every monte step...
    :return: A list of X-pi-half rots for all qudits, starting with the spin.
    """
    X = []
    square_root = 1 / (2 ** (1 / 2))
    rot_matrix = np.array([[1, 0, 0, 0],
                           [0, 1 * square_root, -1j * square_root, 0],
                           [0, -1j * square_root, 1 * square_root, 0],
                           [0, 0, 0, 1],
                           ])
    identity = np.array([[1, 0, 0, 0],
                         [0, 1, 0, 0],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]], dtype=np.complex128)

    X_rot_spin = spin_unitary(0, np.pi / 7, 3.5, deltaOH)
    for i in range(numb_photons):
        X_rot_spin = np.kron(X_rot_spin, identity)
    X.append(X_rot_spin)
    for i in range(numb_photons):
        if i == 0:
            op = np.kron(identity, rot_matrix)
        else:
            op = np.kron(identity, identity)
        for j in range(1, numb_photons):
            if i == j:
                op = np.kron(op, rot_matrix)
            else:
                op = np.kron(op, identity)
        X.append(op)

    return X


def extract_LC_sequences(local_ops, Z, X, three_qubit = True):
    """

    :param graph:
    :param local_ops: Should be on the form [[X-rot qubit, [Z-rot qubits], ...]
    :param Z: All Z rots needed for LC-op
    :param X: All X_rots needed for LC-op
    :param three_qubit: If we are calling three_qubit function
    :return: return LC-sequence but with the appropiate operators
    """
    LC_sequence = []
    if three_qubit == True:

        target, neighbours = local_ops
        X_rot = X[target]
        Z_rots = [Z[i] for i in neighbours]
        LC_sequence.append(X_rot)
        for Z in Z_rots:
            LC_sequence.append(Z)
    else:

        target, neighbours = local_ops
        X_rot = X[target]
        Z_rot = [Z[i] for i in neighbours]
        LC_sequence.append(X_rot)
        LC_sequence.append(Z_rot)
    return LC_sequence


def measurement_rot_unitary(theta, axis):
    identity_part = np.array([[1 / 4, 0, 0, 0],
                              [0, 1 * np.cos(theta), 0, 0],
                              [0, 0, 1 * np.cos(theta), 0],
                              [0, 0, 0, 1 / 4]])

    x_part = np.array([[1 / 4, 0, 0, 0],
                       [0, 0, 1 * (-1j) * np.sin(theta), 0],
                       [0, 1 * (-1j) * np.sin(theta), 0, 0],
                       [0, 0, 0, 1 / 4]])

    y_part = np.array([[1 / 4, 0, 0, 0],
                       [0, 0, -1j * (-1j) * np.sin(theta), 0],
                       [0, 1j * (-1j) * np.sin(theta), 0, 0],
                       [0, 0, 0, 1 / 4]])

    z_part = np.array([[1 / 4, 0, 0, 0],
                       [0, 1 * (-1j) * np.sin(theta), 0, 0],
                       [0, 0, -1 * (-1j) * np.sin(theta), 0],
                       [0, 0, 0, 1 / 4]]
                      )
    if axis == "Z":
        rotation_unitary = identity_part + z_part

    elif axis == "X":
        rotation_unitary = identity_part + x_part

    elif axis == "Y":
        rotation_unitary = identity_part + y_part

    else:
        rotation_unitary = identity_part + y_part + x_part + z_part

    return rotation_unitary
